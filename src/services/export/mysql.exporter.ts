import { DiagramContent, DiagramNode } from '../../types/diagram';

export class MysqlExporter {
    static generate(diagram: DiagramContent): string {
        const tables = diagram.nodes.filter(n => n.type === 'mysqlTable');
        if (tables.length === 0) return '-- No MySQL tables found in diagram';

        let sql = `-- Generated by Moon Modeler\n-- Database: MySQL\n\n`;

        // 1. Create Tables
        tables.forEach(table => {
            sql += this.createTableSql(table);
        });

        sql += `\n-- Foreign Keys\n`;

        // 2. Foreign Keys
        // Strategy: Iterate edges. If Source Table has a field marked isForeignKey
        // AND that field name looks like it references Target (or generic FK), generate constraint.
        // Since we don't track Edge->Column binding strictly yet in the MVP store,
        // we'll assume valid relationships are drawn.

        diagram.edges.forEach(edge => {
            const sourceNode = tables.find(t => t.id === edge.source);
            const targetNode = tables.find(t => t.id === edge.target);

            if (sourceNode && targetNode) {
                // Find potential FK column in source
                // Naive Heuristic: Field marked as FK. 
                // Enhanced: Field name contains target name or is 'target_id'.
                const fkField = sourceNode.data.fields.find(f => f.isForeignKey);

                if (fkField) {
                    sql += this.createForeignKeySql(sourceNode, fkField, targetNode);
                }
            }
        });

        return sql;
    }

    private static createTableSql(table: DiagramNode): string {
        const tableName = table.data.label || 'untitled_table';

        const columnDefs = table.data.fields.map(field => {
            let colSql = `  \`${field.name}\` ${field.type}`;

            if (!field.isNullable) colSql += ' NOT NULL';
            if (field.isPrimaryKey) colSql += ' PRIMARY KEY';
            if (field.isUnique && !field.isPrimaryKey) colSql += ' UNIQUE';

            return colSql;
        });

        return `CREATE TABLE \`${tableName}\` (\n${columnDefs.join(',\n')}\n);\n\n`;
    }

    private static createForeignKeySql(source: DiagramNode, field: any, target: DiagramNode): string {
        const sourceTable = source.data.label;
        const targetTable = target.data.label;
        const constraintName = `fk_${sourceTable}_${field.name}`;

        // Assume target PK is the first PK field found, or 'id'
        const targetPk = target.data.fields.find(f => f.isPrimaryKey)?.name || 'id';

        return `ALTER TABLE \`${sourceTable}\`\n  ADD CONSTRAINT \`${constraintName}\`\n  FOREIGN KEY (\`${field.name}\`)\n  REFERENCES \`${targetTable}\`(\`${targetPk}\`);\n\n`;
    }
}
